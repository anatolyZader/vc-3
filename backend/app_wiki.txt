eventstorm.me Application Review

the previous name of the eventstorm.me app was Videocode



Overview
eventstorm.me is a cloud-native, modular monolith developer toolkit that empowers full-stack software development through intelligent automation, interactive AI tooling, and strict adherence to modern architectural principles. Built on a React + Fastify stack and designed using Domain-Driven Design (DDD) and Hexagonal Architecture, the application offers a suite of integrated tools aimed at improving developer workflow, requirement management, and project visibility.

This document provides an in-depth review of the architecture, design decisions, features, and capabilities of the application.

1. üìê Architectural Design
1.1 Modular Monolith
The backend is implemented as a modular monolith, enabling:

Clear bounded contexts

Encapsulation of domain logic

Efficient inter-module communication using Google Cloud Pub/Sub

Modules are classified as:

Business Modules (isolated, DDD-driven)

Cross-Cutting Modules (AOP-style, plugin-accessible)

1.2 Domain-Driven Design (DDD)
Each business module represents a bounded context and contains:

Aggregates

Entities

Value Objects

Domain Events

Application Services

Ports and Adapters (Hexagonal style)

This design enforces separation of concerns and promotes business-centric modeling.

1.3 Hexagonal Architecture (Ports and Adapters)
All modules follow a layered structure:

domain/: Pure business logic

application/: Use cases and service orchestration

infrastructure/: Adapters (e.g., PostgreSQL, Redis, Pub/Sub, APIs)

Inbound ports include HTTP routes and Pub/Sub listeners, while outbound ports enable communication with databases, caches, and third-party services.

2. ‚öôÔ∏è Runtime Infrastructure
Layer	Technology
Frontend	React + Vite
Backend	Fastify (Node.js)
CI/CD	GitHub Actions
Runtime (Prod)	Google Cloud Run
Client Hosting	GCP Storage Bucket
Load Balancing	GCP Global Load Balancer
DB (Dev & Prod)	Cloud SQL (PostgreSQL)
Cache	Memorystore (Redis)
Messaging	Google Cloud Pub/Sub
Auth	Google OAuth2 + JWT
HTTPS	NGINX reverse proxy (Dev), GCP SSL cert (Prod)

3. üß© Modules
3.1 Business Modules
Module	Description
chat_module	Acts as the central fa√ßade. Handles client interaction and delegates to other modules via Pub/Sub.
ai_module	Core intelligence unit. Utilizes LangChain and RAG pipelines to synthesize insights and responses.
git_module	Provides Git repository analysis and embeds source context into the AI pipeline.
docs_module ‚Üí insight_module (renamed)	Supplies textual application knowledge and architecture descriptions.
requirements_module	Generates and manages structured requirements derived from DDD event storming.
pm_module	Integrates with Jira (via adapters). Supplies sprint, task, and status data.
api_module	Feeds Swagger/OpenAPI specs into the AI pipeline for endpoint awareness.
monitoring_module	Supplies real-time metrics from GCP for observability and RAG-based system health briefings.

Each module:

Is independently encapsulated

Communicates only via Pub/Sub

Maintains its own adapters and logic

Has no direct access to other modules' internals

3.2 Cross-Cutting Modules
Module	Responsibility
auth	Handles OAuth2 (Google), JWT issuance, and role-based access control.
log	Centralized logging pipeline, exposed as a Fastify plugin.
pubsub	Encapsulates GCP Pub/Sub publishing and subscription logic.
error	Unified error formatting and propagation plugin.
test	Validates AI-generated tests for quality before execution.

Cross-cutting modules use Fastify plugin architecture, not middleware, and follow plugin encapsulation rules.

4. üß† Key Features
4.1 AI-Driven Developer Toolkit
Tool	Function
Briefing Tool	Provides up-to-date project summaries, change tracking, sprint insights, and planning discrepancies.
Review Tool	Generates a professional, structured application description tailored to audience needs.
Event Storming Simulator	Simulates DDD event storming sessions; produces user stories and requirements from discussion.
Voice Interaction	Integrates GCP Text-to-Speech and Speech-to-Text for natural voice-based interactions.

All tools are backed by a centralized LangChain-powered RAG pipeline, with sources including:

Git (codebase analysis)

Insight (textual documentation)

Requirements (structured goals)

API specs (OpenAPI/Swagger)

Monitoring (GCP system metrics)

4.2 Separation of Environments
Development: GCP VM + VSCode Remote SSH

Staging: Cloud Run + Load Balancer + GCP Storage + HTTPS

Build separation ensures safety and cost-effectiveness, while GitHub Actions automate deployments.

4.3 Encapsulation and Messaging
Business modules do not import from one another

Communication is async, event-based via Pub/Sub

Controlled exposure using adapter pattern and public events only

5. üîí Authentication & Authorization
Uses @fastify/oauth2 and Google OAuth2 redirect-based login

Issues secure JWTs for authenticated sessions

Role-based access is enforced via Fastify hooks and an integrated permissions system

Session state is managed with cookies, and sensitive paths are protected through route-level onRequest hooks.

6. üîç Observability and Testing
Logging: AOP logging plugin with environment-aware verbosity

Monitoring: GCP metrics integrated into AI briefings

Testing: AI-generated tests are validated in the test module

Schema Validation: All inputs validated with shared JSON schemas

Fastify provides rich per-request logs and internal hooks for health checks and diagnostics.

7. ‚úÖ Best Practice Highlights
Practice	Implementation Details
DDD + Hexagonal	Fully respected per module; rich domain models are defined cleanly in domain/ folders
Clean Separation of Layers	No leakage of infrastructure logic into domain or application layers
Messaging-First Design	Modules interact only via Pub/Sub with strict encapsulation
Fastify Plugin Usage	AOP modules and root-level concerns are implemented as encapsulated plugins
GitHub Actions CI/CD	Continuous deployments tied to commits and branch tracking
Environment Awareness	.env files and service-specific configurations segregate dev vs staging
Type-Safe Validation	JSON schemas integrated with TypeScript for robust API and message validation

8. üìà Planned Enhancements
Fine-grained access policies for different tools

Adaptive test generation based on recent commits and requirements deltas

Intelligent alerting for discrepancies between current code and documented goals

Collaboration Module to support team-based voice and chat interactions

Conclusion
eventstorm.me represents a mature, thoughtfully architected developer toolkit that demonstrates deep fluency in backend architecture, software design, and modern cloud-native practices. Its design prioritizes encapsulation, flexibility, and developer ergonomics while leveraging AI to automate key parts of the development lifecycle.

This system is not only a technical demonstration but also an evolving assistant to the developer, helping them reflect, plan, and improve continuously.

