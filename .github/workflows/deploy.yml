name: Full deploy

on:
  push:
    branches: [amber]  # Triggers the workflow on pushes to the 'amber' branch

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      GOOGLE_APPLICATION_CREDENTIALS: ${{ secrets.GCP_SA_KEY }}
      GCP_PROJECT: eventstorm-1
      REGION: me-west1
      GCP_BUCKET: eventstorm-bucket
      REDIS_HOST: 10.187.8.27

      # These environment variables are made available to steps within this GitHub Actions job.
      # They are also explicitly passed to Cloud Run in the deploy step.
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
      PINECONE_API_KEY: ${{ secrets.PINECONE_API_KEY }}
      PINECONE_ENVIRONMENT: ${{ secrets.PINECONE_ENVIRONMENT }}
      PINECONE_INDEX_NAME: ${{ secrets.PINECONE_INDEX_NAME }}


    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Get full history for better documentation context

    - name: Authenticate with GCP
      uses: google-github-actions/auth@v2
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.GCP_PROJECT }}

    - name: Debug GCP Auth
      run: |
        gcloud auth list
        gcloud config list
        gsutil ls gs://$GCP_BUCKET/

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22.x'

    # --- FRONTEND: Build & Upload ---
    - name: Build React client
      run: |
        cd client
        npm ci
        npm run build

    - name: Clear bucket
      run: |
        gsutil -m rm -r gs://$GCP_BUCKET/** || true

    - name: Upload static files
      run: |
        gsutil -m rsync -r ./client/dist gs://$GCP_BUCKET/

    # --- BACKEND: Install dependencies first ---
    - name: Install backend dependencies
      run: |
        cd backend
        npm ci

    # --- VALIDATE WIKI ENVIRONMENT ---
    - name: Validate wiki environment
      run: |
        cd backend
        echo "üîç Validating wiki documentation environment..."
        
        # Check if required files exist
        if [ ! -f "wiki-cli.js" ]; then
          echo "‚ùå wiki-cli.js not found"
          exit 1
        fi
        
        if [ ! -f "business_modules/wiki/input/wikiCli.js" ]; then
          echo "‚ùå wikiCli.js not found"
          exit 1
        fi
        
        echo "‚úÖ Wiki CLI files found"
        
        # Check environment variables
        if [ -z "$PINECONE_API_KEY" ]; then
          echo "‚ùå PINECONE_API_KEY not set"
          exit 1
        fi
        
        if [ -z "$OPENAI_API_KEY" ] && [ -z "$ANTHROPIC_API_KEY" ] && [ -z "$GOOGLE_API_KEY" ]; then
          echo "‚ùå No AI provider API key set"
          exit 1
        fi
        
        echo "‚úÖ Required environment variables set"

    # --- GENERATE COMPREHENSIVE DOCUMENTATION ---
    - name: Generate comprehensive documentation
      run: |
        cd backend
        echo "üìö Starting wiki documentation generation..."
        echo "üîó Using deployment user ID: deployment-${{ github.run_id }}"
        echo "üìÖ Generation timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        
        # Check if the script exists first
        if [ ! -f "wiki-cli.js" ]; then
          echo "‚ùå wiki-cli.js not found in $(pwd)"
          ls -la
          exit 1
        fi
        
        # Test the CLI directly first
        echo "üß™ Testing wiki CLI with --help"
        node wiki-cli.js --help || {
          echo "‚ùå Wiki CLI help command failed"
          exit 1
        }
        
        # Run with timeout to prevent hanging - but make it optional to continue deployment
        echo "üöÄ Running wiki generation (non-blocking)..."
        timeout 300 npm run wiki:generate -- --user-id deployment-${{ github.run_id }} || {
          echo "‚ö†Ô∏è Wiki generation timed out or failed, but continuing deployment"
          echo "üìã Checking for partial results..."
          ls -la business_modules/*/
          echo "üìã This is non-fatal - deployment will continue"
        }
        
        echo "‚úÖ Wiki documentation step completed (success or graceful failure)"
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
        PINECONE_API_KEY: ${{ secrets.PINECONE_API_KEY }}
        PINECONE_ENVIRONMENT: ${{ secrets.PINECONE_ENVIRONMENT }}
        PINECONE_INDEX_NAME: eventstorm-wiki

    - name: Verify generated documentation (optional)
      run: |
        cd backend
        echo "üîç Checking for generated documentation files..."
        
        # Check for module documentation
        MODULES_WITH_DOCS=0
        for module_dir in business_modules/*/; do
          module_name=$(basename "$module_dir")
          doc_file="${module_dir}${module_name}.md"
          if [ -f "$doc_file" ]; then
            echo "‚úÖ Found documentation: $doc_file"
            MODULES_WITH_DOCS=$((MODULES_WITH_DOCS + 1))
            
            # Check file size (should be substantial)
            file_size=$(wc -c < "$doc_file")
            if [ "$file_size" -lt 100 ]; then
              echo "‚ö†Ô∏è Warning: $doc_file seems too small ($file_size bytes)"
            else
              echo "üìÑ $doc_file size: $file_size bytes"
            fi
          else
            echo "‚ö†Ô∏è Missing documentation: $doc_file"
          fi
        done
        
        # Check for root documentation
        if [ -f "ROOT_DOCUMENTATION.md" ]; then
          echo "‚úÖ Found ROOT_DOCUMENTATION.md"
          root_size=$(wc -c < "ROOT_DOCUMENTATION.md")
          echo "üìÑ ROOT_DOCUMENTATION.md size: $root_size bytes"
        else
          echo "‚ö†Ô∏è Missing ROOT_DOCUMENTATION.md"
        fi
        
        # Check for architecture documentation
        if [ -f "ARCHITECTURE.md" ]; then
          echo "‚úÖ Found ARCHITECTURE.md"
          arch_size=$(wc -c < "ARCHITECTURE.md")
          echo "üìÑ ARCHITECTURE.md size: $arch_size bytes"
        else
          echo "‚ö†Ô∏è Missing ARCHITECTURE.md"
        fi
        
        echo "üìä Summary: $MODULES_WITH_DOCS modules have documentation"
        
        # This is now informational only - don't fail the build
        if [ "$MODULES_WITH_DOCS" -eq 0 ] && [ ! -f "ROOT_DOCUMENTATION.md" ] && [ ! -f "ARCHITECTURE.md" ]; then
          echo "‚ö†Ô∏è No documentation was generated, but deployment will continue"
        else
          echo "‚úÖ Some documentation was generated successfully"
        fi

    # --- PRE-DEPLOYMENT VALIDATION ---
    - name: Validate deployment prerequisites
      run: |
        cd backend
        echo "üîç Pre-deployment validation..."
        
        # Check critical files exist
        echo "üìÅ Checking critical files..."
        [ -f "package.json" ] && echo "‚úÖ package.json found" || { echo "‚ùå package.json missing"; exit 1; }
        [ -f "server.js" ] && echo "‚úÖ server.js found" || { echo "‚ùå server.js missing"; exit 1; }
        [ -f "app.js" ] && echo "‚úÖ app.js found" || { echo "‚ùå app.js missing"; exit 1; }
        
        # Check package.json structure
        echo "üì¶ Validating package.json..."
        node -e "const pkg = require('./package.json'); console.log('‚úÖ Package name:', pkg.name); console.log('‚úÖ Main script:', pkg.main || 'not specified'); console.log('‚úÖ Start script:', pkg.scripts?.start || 'not specified');"
        
        # Test if the application can start (dry run)
        echo "üß™ Testing application startup (dry run)..."
        timeout 10 node -e "
          console.log('Testing basic Node.js execution...');
          try {
            require('./server.js');
            console.log('‚úÖ server.js loads without immediate errors');
          } catch (error) {
            console.log('‚ùå server.js has loading issues:', error.message);
            process.exit(1);
          }
        " || echo "‚ö†Ô∏è Startup test timed out or failed - this may be normal for server files"
        
        # Check file sizes (large files can cause build issues)
        echo "ÔøΩ Checking for large files that might cause build issues..."
        find . -type f -size +10M -not -path "./node_modules/*" -not -path "./.git/*" | while read file; do
          size=$(du -h "$file" | cut -f1)
          echo "‚ö†Ô∏è Large file detected: $file ($size)"
        done
        
        # Check directory structure
        echo "üìÇ Directory structure:"
        ls -la
        echo "üìÇ Business modules:"
        ls -la business_modules/ || echo "‚ö†Ô∏è No business_modules directory"

    - name: Create .gcloudignore file
      run: |
        cd backend
        echo "üìù Creating .gcloudignore to optimize build..."
        cat > .gcloudignore << 'EOF'
        # Ignore development and testing files
        .git/
        .gitignore
        README.md
        *.md
        .env
        .env.*
        
        # Ignore test files
        _tests_/
        test/
        tests/
        *.test.js
        *.spec.js
        
        # Ignore development tools
        .eslintrc*
        eslint.config.js
        jest.config.js
        
        # Ignore logs and temporary files
        logs/
        *.log
        cloud_run_logs.txt
        logs_run.txt
        
        # Ignore large files that aren't needed for runtime
        bfg.jar
        cloud-sql-proxy
        *.zip
        *.tar.gz
        
        # Include only essential files for runtime
        !package.json
        !package-lock.json
        !server.js
        !app.js
        !fastify.config.js
        !business_modules/
        !aop_modules/
        !env_schemas/
        !*.js
        EOF
        
        echo "‚úÖ .gcloudignore created:"
        cat .gcloudignore

    - name: Deploy backend to Cloud Run (with detailed logging)
      run: |
        cd backend
        echo "üöÄ Starting Cloud Run deployment..."
        echo "üìÇ Current directory: $(pwd)"
        echo "üìã Files to be deployed:"
        ls -la
        
        echo "üîß Deployment configuration:"
        echo "  ‚Ä¢ Service: eventstorm-backend"
        echo "  ‚Ä¢ Region: $REGION"
        echo "  ‚Ä¢ Project: $GCP_PROJECT"
        echo "  ‚Ä¢ Source: current directory"
        
        # Set verbose logging for gcloud
        export CLOUDSDK_CORE_VERBOSITY=info
        
        echo "üöÄ Executing deployment command..."
        
        gcloud run deploy eventstorm-backend \
          --source . \
          --region $REGION \
          --project $GCP_PROJECT \
          --platform managed \
          --vpc-connector=cr-vpc-conn \
          --allow-unauthenticated \
          --memory=2Gi \
          --cpu=2 \
          --timeout=900 \
          --max-instances=10 \
          --set-secrets=USER_OAUTH2_CREDENTIALS=google-creds:latest \
          --set-env-vars=NODE_ENV=staging,REDIS_PORT=6379,PG_USER=postgres,PG_DATABASE=eventstorm_db,JWT_EXPIRE_IN=1h,REDIS_HOST=$REDIS_HOST,CLOUD_SQL_CONNECTION_NAME=eventstorm-1:me-west1:eventstorm-pg-instance-1,DEPLOYMENT_TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ"),DEPLOYMENT_RUN_ID=${{ github.run_id }} \
          --set-env-vars=OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }},ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }},GOOGLE_API_KEY=${{ secrets.GOOGLE_API_KEY }},PINECONE_API_KEY=${{ secrets.PINECONE_API_KEY }},PINECONE_ENVIRONMENT=${{ secrets.PINECONE_ENVIRONMENT }},PINECONE_INDEX_NAME=${{ secrets.PINECONE_INDEX_NAME }} \
          --set-secrets=JWT_SECRET=jwt-secret:latest,GCP_OAUTH2_CLIENT_SECRET=google-oauth2-secret:latest,PG_PASSWORD=pg-pwd:latest,COOKIE_SECRET=cookie-secret:latest,SESSION_SECRET=session-secret:latest,GITHUB_TOKEN=github-token:latest \
          --verbosity=info

    - name: Post-deployment verification
      if: success()
      run: |
        echo "‚úÖ Deployment completed successfully!"
        echo "üîç Verifying deployment..."
        
        # Get service URL
        SERVICE_URL=$(gcloud run services describe eventstorm-backend --region=$REGION --format='value(status.url)')
        echo "üåê Service URL: $SERVICE_URL"
        
        # Test basic connectivity (with timeout)
        echo "üß™ Testing service connectivity..."
        timeout 30 curl -s "$SERVICE_URL/health" || echo "‚ö†Ô∏è Health check endpoint not responding (this may be normal if no health endpoint exists)"

    - name: Deployment failure diagnostics
      if: failure()
      run: |
        echo "‚ùå Deployment failed - gathering diagnostic information..."
        
        cd backend
        echo "üìÇ Current directory contents:"
        ls -la
        
        echo "üì¶ Package.json contents:"
        cat package.json
        
        echo "üîç Checking recent Cloud Build logs..."
        gcloud logging read "resource.type=build AND severity>=WARNING" --limit=10 --format="table(timestamp,severity,textPayload)" --project=$GCP_PROJECT || echo "Could not retrieve build logs"
        
        echo "üîç Checking Cloud Run service status..."
        gcloud run services describe eventstorm-backend --region=$REGION --project=$GCP_PROJECT || echo "Service not found or accessible"
        
        echo "üí° Common solutions:"
        echo "  1. Check that all required files are present"
        echo "  2. Verify package.json has correct start script"
        echo "  3. Ensure no syntax errors in JavaScript files"
        echo "  4. Check for missing dependencies"
        echo "  5. Verify environment variables are correctly set"

    # --- SAVE DOCUMENTATION ARTIFACTS ---
    - name: Archive documentation artifacts
      uses: actions/upload-artifact@v4
      if: always() # Upload even if previous steps failed
      with:
        name: generated-documentation-${{ github.run_id }}
        path: |
          backend/business_modules/*/*.md
          backend/ROOT_DOCUMENTATION.md
          backend/ARCHITECTURE.md
        retention-days: 30

    # --- TRIGGER AI INGESTION via Pub/Sub ---
    - name: Install jq for JSON templating
      run: sudo apt-get update && sudo apt-get install -y jq

    - name: Publish repoPushed event for AI ingestion
      env:
        TOPIC: git-topic # Or 'ai-topic' if that's the final designated topic where AI listener subscribes
        USER_ID: ${{ github.actor }} # The user who triggered the push
        REPO_NAME: ${{ github.event.repository.name }}
        REPO_OWNER: ${{ github.event.repository.owner.login }}
        BRANCH_NAME: ${{ github.ref_name }} # The branch name that was pushed to
        CORRELATION_ID: ${{ github.run_id }}
      run: |
        REPO_URL="https://github.com/$REPO_OWNER/$REPO_NAME"
        PAYLOAD=$(jq -n \
          --arg event "repoPushed" \
          --arg userId "$USER_ID" \
          --arg repoId "$REPO_NAME" \
          --arg repoUrl "$REPO_URL" \
          --arg branch "$BRANCH_NAME" \
          --arg corr "$CORRELATION_ID" \
          --arg deploymentId "deployment-${{ github.run_id }}" \
          '{ event: $event, payload: { userId: $userId, repoId: $repoId, repoData: { url: $repoUrl, branch: $branch, deploymentId: $deploymentId }, correlationId: $corr } }'
        )
        echo "Publishing to topic $TOPIC with payload: $PAYLOAD"
        gcloud pubsub topics publish "$TOPIC" --message="$PAYLOAD"

    # --- OPTIONAL: Publish wiki update event ---
    - name: Publish wiki documentation updated event
      env:
        TOPIC: wiki-topic # Assuming you have a wiki-specific topic
        USER_ID: deployment-${{ github.run_id }}
        CORRELATION_ID: ${{ github.run_id }}
      run: |
        PAYLOAD=$(jq -n \
          --arg event "wikiDocumentationUpdated" \
          --arg userId "$USER_ID" \
          --arg timestamp "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
          --arg corr "$CORRELATION_ID" \
          --arg deploymentId "deployment-${{ github.run_id }}" \
          '{ event: $event, payload: { userId: $userId, timestamp: $timestamp, deploymentId: $deploymentId, correlationId: $corr } }'
        )
        echo "Publishing wiki update event to topic $TOPIC with payload: $PAYLOAD"
        gcloud pubsub topics publish "$TOPIC" --message="$PAYLOAD" || echo "‚ö†Ô∏è Wiki topic not available, skipping"

    # --- GENERATE & SAVE OPENAPI SPEC ---
    - name: Generate OpenAPI spec file
      working-directory: backend
      run: |
        npm run generate:spec || echo "‚ö†Ô∏è OpenAPI generation failed, continuing deployment"